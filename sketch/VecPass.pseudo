/********************************************************************************************* 
*
* Step 1: From graph only consider the operations that are vectorizable 
* Step 2: Fuse vectorizable operations together 
* Step E: Rewrite MLIR 
*
*********************************************************************************************/

struct Graph:

struct Node:

struct FusionNode:

function VectorPass(Graph cfg):

    // Step 1: Identify potential fusable operations
    queue = []
    for node in cfg.nodes:
        if type(op) is MatrixOp or type(op) is SinkOp or type(op) is SourceOp:
            queue.append(node)
    
    // Step 2: Fusing adjacent nodes
    while vectorizable_operations.size() != 0:
        op = queue.dequeue()
        fuseOp = fuseWithNeighbors(op, queue)
        if fuseOp != null:
            for op in fuseOp.:
                removeOpFromGraph(cfg, op)
            queue.append(fusionNode)


function fuseWithNeighbors(Operation op, queue):
    //maybe only in one direction? cause it is easier?