/********************************************************************************************* 
*
* Step 1: From graph only consider the operations that are vectorizable 
* Step 2: Fuse vectorizable operations together 
* Step E: Rewrite MLIR 
*
*********************************************************************************************/

struct Graph:
    Node* nodes = []
    //Bit** edges = [][] //adjacent matrix

struct Node:
    Type opType = MatrixOp | MatrixSinkOp | MatrixSourceOp
    Node* inputs = []
    Node* outputs = []

struct Pipeline of Node:
    Type opType = FuseOp
    Graph block = null

function VectorPass(Graph cfg):

    // Step 1: Identify potential fusable operations
    // Only considering them specified in the function isVectorizable
    // directly "divides" graph in multiple pipelines as breaking operations
    // are not part of releveant opTypes
    queue = [] // FIFO
    for node in _cfg.nodes:
        if isVectorizable(node):
            queue.append(node)
    
    // Step 2: Fusing adjacent nodes
    // Heuristic: greedily fuse operations together
    while queue.size() != 0:
        op = queue.dequeue()
        
        toReplaceOps = []
        for parent in op.inputs:
            if isVectorizable(parent):
                toReplaceOps.add(parent)

        if toReplaceOps.size() > 0:
            if op.opType == FuseOp:
                fusionNode.block.addNode(toReplaceOps)
                fusionNode.inputs = toReplaceOps.inputs
            else:
                fusionNode = FusedNode(op, toReplaceOps)
                removeNodeFromGraph(_cfg, op)
                removeNodeFromGraph(_cfg, toReplaceOps)
                addNodeToGraph(_cfg, fusionNode)
            queue.append(fusionNode)

   return cfg 
    
function isVectorizable(Node op):
    if op.opType is in (MatrixOp, MatrixSinkOp, MatrixSourceOp, FuseOp):
        return true
    return false