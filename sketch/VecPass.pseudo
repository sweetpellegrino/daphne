/********************************************************************************************* 
*
* Step 1: From graph only consider the operations that are vectorizable 
* Step 2: Fuse vectorizable operations together 
* Step E: Rewrite MLIR 
*
*********************************************************************************************/

struct Graph:
    Node* nodes = []
    Bit** edges = [][] //adjacent matrix

struct Node:
    Type opType = MatrixOp | MatrixSinkOp | MatrixSourceOp
    Node* inputs = []
    Node* outputs = []

struct FusedNode of Node:
    Type opType = FuseOp
    Graph replacedOps = []

function VectorPass(Graph cfg):

    _cfg = deepcopy(cfg)

    // Step 1: Identify potential fusable operations
    // Only considering them specified in the function isVectorizable
    // directly "divides" graph in multiple pipelines as breaking operations
    // are not part of releveant opTypes
    queue = [] // FIFO
    for node in _cfg.nodes:
        if isVectorizable(node):
            queue.append(node)
    
    // Step 2: Fusing adjacent nodes
    // Heuristic: greedily fuse operations together
    while queue.size() != 0:
        op = queue.dequeue()
        
        toReplaceOps = []
        for parent in op.inputs:
            if isVectorizable(parent) == true:
                (op, toReplaceOps)

        toReplaceOps = 
        if len(toReplaceOps) > 0:
            fuseOp = FusedNode(op, toReplaceOps)
            removeOpFromGraph(_cfg, op)
            removeOpFromGraph(_cfg, toReplaceOps)
            queue.append(fusionNode)
    
    //_cfg should now consist of only "disjunct" fuseOp

    // Step 3: Rewrite original graph
    for fusedOp in _cfg.nodes:

    
    
function isVectorizable(Node op):
    if op.opType is in (MatrixOp, MatrixSinkOp, MatrixSourceOp, FuseOp):
        return true
    return false